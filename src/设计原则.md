# **七大设计原则**

> 单一职责原则：专注降低类的复杂度，实现类要职责单一
>
> 依赖倒置原则：系统抽象化的具体实现，要求面向接口编程，是面向对象设计的主要实现机制之一
>
> 接口隔离原则：要求接口的方法尽量少，接口尽量细化
>
> 开放关闭原则：所有面向对象原则的核心，设计要对扩展开发，对修改关闭
>
> 里式替换原则：实现开放关闭原则的重要方式之一，设计不要破坏继承关系
>
> 迪米特法则：降低系统的耦合度，使一个模块的修改尽量少的影响其他模块，扩展会相对容易
>
> 组合复用原则：在软件设计中，尽量使用组合/聚合而不是继承达到代码复用的目的

## 1、单一职责原则 SRP（Single Responsibility Principle）

#### （1）是什么？

就一个类而言，应该仅有一个引起它变化的原因，通俗的说，就是一个类只负责一项职责（可以到方法层，即一个方法只做一个功能）。此原则的核心就是解耦和增强内聚性。

#### （2）为什么要使用单一职责原则？

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这样就会增加类的耦合性，导致这个类会非常臃肿。

#### （3）优点：

1. 降低类的复杂度
2. 提高类的可读性，提高系统的可维护性
3. 降低变更引起的风险（降低对其他功能的影响。

## 2、接口隔离原则 ISP （Interface Segregation Principle）

#### （1）是什么？

接口隔离原则讲的是：使用多个专门的接口比使用单一的接口要好。换句话来说，就是从一个客户类的角度来说，一个类对另外一个类的依赖性应当是建立在最小的接口上的。

#### （2）理解

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，==接口中的方法尽量少==。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。但其实接口隔离原则也算是“看人下菜碟”，要根据客户不同的需求，去指定不同的服务，这就是接口隔离原则中推荐的方式。

## 3、依赖倒转原则 DIP （Dependence Inversion Principle）

高层模块不应该依赖低层模块，二者都应该依赖其抽象；
==抽象不应该依赖细节，细节应该依赖抽象==，这个是开闭原则的基础。
具体内容：针对接口编程，==依赖于抽象而不依赖于具体==。
面向接口的编程，多用抽象的接口来描述相同的动作。

## 4、里氏代换原则 LSP （Liskov Substitution Principle）

里氏代换原则中说，==任何基类可以出现的地方，子类一定可以出现==。即在一个程序中，在使用基类的地方，用其子类替换，程序应该继续能运行。

LSP是继承复用的基石，只有当衍生类（子类）可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类（子类）也能够在基类的基础上增加新的行为。==里氏代换原则是对“开-闭”原则的补充==。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
2. 子类中可以增加自己特有的方法。
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格

**一句话总结：**尽量不要重写父类的已经实现了的方法，可以用接口等其他方法绕过

## 5、开闭原则 OCP （Open Close Principle）

开闭原则就是说==对扩展开放，对修改关闭==。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

在开闭原则中，==抽象化是一个关键，解决问题的关键在于抽象化==。在 Java 语言中，可以给出一个或者多个Java 抽象类或者是Java接口，规定所有的具体类必须提供方法特征作为系统设计的抽象层，这个抽象层会遇见所有的可能出现的扩展，因此，在任何扩展情况下都不回去改变，这就让系统的抽象层不需要修改，从而满足开闭原则的第二条，对修改进行闭合。

##  6、迪米特法则（最少知道原则） DP （Demeter Principle）

迪米特法则又叫作==最少知识原则==（Least Knowledge Principle 简写LKP）。

**为什么叫最少知道原则？**

就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
其实它主要是为了解决一个我们最常见的问题，就是类之间的关系，所以类与类之间的关系越密切，耦合度就越大，当一个类放生改变的时间，对另一个类的影响也会越大。

而它最终的解决方案就是降低类和类之间的耦合度，这也是我们所说的高内聚，低耦合。

**为了避免知道的太多，这个原则提供了一些方针：**

就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：
- 该对象本身
- 被当作方法的参数而传递进来的对象
- 此方法所创建或实例化的任何对象
- 对象的任何组件

请注意：这些方针告诉我们，如果==某对象是调用其他的方法的返回结果，不要调用该对象的方法==

## 7、合成复用原则（Composite Reuse Principle）

**==原则是尽量使用合成/聚合的方式，而不是使用继承。==**

该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。而在我们的代码中尽可能使用组合而不是用继承是什么原因呢？原因如下：

1. 继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则；

2. 如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。而用合成和聚合的时候新对象和已有对象的交互往往是通过接口或者抽象类进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。

**合成复用原则使用建议：**

合成和聚合均是关联的特殊情况。聚合用来表示“拥有”关系或者整体与部分的关系；而合成则用来表示一种强得多的“拥有”关系。==在一个合成关系里面，部分和整体的生命周期是一样的。一个合成的新的对象完全拥有对其组成部分的支配权，包括它们的创建和销毁等。==使用程序语言的术语来说，组合而成的新对象对组成部分的内存分配、内存释放有绝对的责任。要正确的选择合成/复用和继承，必须透彻地理解里氏替换原则。

